

























































[TOC]

# 总结

计算机底层在保存时间时使用都是时间戳      

 JS底层保存标识符时实际上是采用的Unicode编码

在底层字符串是以字符数组的形式保存的

如果符号两侧的值都是字符串时，不会将其转换为数字进行比较,而会分别比较字符串中字符的Unicode编码。sort()按照Unicode编码进行排序

## 1、**typeof**

就是运算符，可以来获得一个值的类型 它会将该值的类型以**字符串**的形式返回 number string boolean undefined object

​      （1）**函数**：使用typeof检查一个函数对象时，会返回**function**

​      （2）**null**：使用typeof检查一个null值时，会返回object；

​      （3）**object**：使用typeof检查一个对象时，会返回object

​      （4）**Array**:使用typeof检查一个数组时，会返回object

​      （5）**undefined**：使用typeof检查一个undefined时也会返回undefined

​      （6）**正则表达式：** 使用typeof检查正则对象，会返回object

## 2、**NaN**

（1）任何值和NaN做**运算**都得NaN（2）任何值和NaN做任何**比较**都是false（3）NaN不和任何值**相等**，包括他本身（4）   可以通过**isNaN()函数**来判断一个值是否是NaN， 如果该值是NaN则返回true，否则返回false

## 3、**Null和undefined**

（1）使用typeof检查一个null值时，会返回object；使用typeof检查一个undefined时也会返回undefined  **注意：是字符串的形式**

（2）转换类型为number

​          null --> 数字   0                                                                    undefined --> 数字    NaN

（3）转换类型为布尔值

​          null和undefined都会转换为false

（4）相等判断

```
/*
       * undefined 衍生自 null
       * 	所以这两个值做相等判断时，会返回true
*/
      console.log(undefined == null);true
      console.log(null === undefined);//false
```

## **4、字符串比较**

如果符号两侧的值都是字符串时，不会将其转换为数字进行比较（比较数字字符串会得到意外的结果），而会分别比较字符串中字符的Unicode编码

5、显示数据转换

## 6、**隐式数据转换**

（1）string

为任意的数据类型 **+ 一个 ""** 即可将其转换为String， 这是一种隐式的类型转换，由浏览器自动完成，实际上它调用**String()函数**

（2）number

通过为一个值 **-0  *1  /1**来将其转换为Number，原理和**Number()函数**一样，使用起来更加简单

可以对一个其他的数据类型使用**+**一元运算符,来将其转换为number，它的原理和**Number()函数**一样

（3）Boolean

可以为一个任意数据类型取两次反，来将其转换为布尔值，原理和Boolean()函数一样

## 7、 prompt、confirm

 **prompt**

   可以弹出一个提示框，该提示框中会带有一个文本框,用户可以在该文本框中输入一段内容

​       该函数需要一个字符串作为参数，该参数会作为提示框的提示文字

​       用户输入的内容会作为函数的返回值返回，以字符串的形式返回，所以可以使用一个变量接收该内容

```
var score = prompt("请输入小明的期末成绩(0-100):");
```

![image-20230216140204536](C:\Users\ydy\AppData\Roaming\Typora\typora-user-images\image-20230216140204536.png)

**confirm**

用于弹出一个带有确认和取消按钮的提示框

需要一个字符串作为参数，该字符串将会作为提示文字显示出来,如果用户点击确认则会返回true，如果点击取消则返回false

## 8、计时器

​      console.time("计时器的名字")可以用来开启一个计时器，它需要一个字符串作为参数，这个字符串将会作为计时器的标识

​      console.timeEnd()用来停止一个计时器，需要一个计时器的名字作为参数

## **9、break、continue、return**

（1）break

​      可以用来退出switch或循环语句，不能在if语句中使用break和continue。会立即**终止离他最近的那个循环语句**；

​      可以为循环语句创建一个label，来标识当前的循环环语句使用break语句时，可以在break后跟着一个label，将会**结束指定的循环，而不是最近的**

```
outer:
			for(var i=0 ; i<5 ; i++){
				console.log("@外层循环"+i)
				for(var j=0 ; j<5; j++){
					break outer;
					console.log("内层循环:"+j);
				}
```

（2）continue

​         关键字可以用来**跳过当次循环**， 同样continue也是默认只会对离他**最近**的循环循环起作用

（3）return

​          return可以**结束整个函数，后面的代码将不在执行**

## **10、基本数据类型和引用数据类型比较**

**基本数据类型**在栈内存中存储，变量保存的是值，值与值之间是独立存在，修改一个变量不会影响其他的变量

**引用数据类型**是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响

​     当比较两个基本数据类型的值时，就是比较值。而比较两个引用数据类型时，它是**比较的对象的内存地址**，如果两个对象是一摸一样的，但是地址不同，它也会返回false

## 11、mianji和mianji()的区别

  		 * mianji()
  			 * 	- 调用函数
  			 * 	- 相当于使用的函数的返回值
  			 * 
  	     * mianji
  			 * 	- 函数对象
  			 * 	- 相当于直接使用函数对象

## 12、数字转换为指定的进制

对于Number调用toString()时可以在方法中传递一个整数作为参数，此时它将会把数字转换为指定的进制,如果不指定则默认转换为10进制
    a = a.toString(2);

## 13、作用域

作用域指一个变量的作用范围， 在JS中一共有两种作用域

**全局作用域**

​	直接编写在script标签中的JS代码，都在全局作用域

​    全局作用域在**页面打开**时创建，在**页面关闭**时销毁

​    在全局作用域中有一个**全局对象window**，它代表的是一个**浏览器的窗口**，它由浏览器创建我们可以直接使用

​    在全局作用域中：

​    （1）创建的变量都会作为window对象的属性保存

​    （2）创建的函数都会作为window对象的方法保存

​    （3）全局作用域中的变量都是全局变量，在**页面的任意的部分都可以访问的到**

```
//var c = "hello";
console.log(window.c);//"undefined" 对象上不存在该属性
console.log(c);//Uncaught ReferenceError: c is not defined  报错，没有定义变量
```

**函数作用域**

**调用函数**时创建函数作用域，函数执行完毕以后，函数作用域销毁

   * 每调用一次函数就会创建一个新的函数作用域，他们之间是**互相独立**的

   * 在函数作用域中**可以访问到全局作用域的变量**

   * **在全局作用域中无法访问到函数作用域的变量**

   * 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有找到，则会报错**ReferenceError**（如果有this对象，this上没有该属性，会返回undefined，不会寻找）

   * **在函数中要访问全局变量可以使用window对象**

   * 在**函数作用域也有声明提前的特性**，使用var关键字声明的变量，会在函数中所有的代码执行之前被声明，函数声明也会在函数中所有的代码执行之前执行

   *  定义形参就相当于在函数作用域中声明了变量

   * **在函数中，不适用var声明的变量都会成为全局变量**

     	    var c = 33;
                    		function fun5(){
                    			console.log("c = "+c);//33 全局变量，不是var声明变量，变量没有提前，对于此行代码来说，此作用域内没有c，所以向上一级作用域中寻找
                    			//全局声明
                    			c = 10;
                    			console.log("c = "+c);//10   
                    			//d没有使用var关键字，则会设置为全局变量
                    			d = 100;
                    		}
                    		fun5();
                    		console.log("c = "+c);//10 调用函数，函数中的C是全局声明，会覆盖前面的c

     **函数内形参和var声明的变量属于它自己，对其进行赋值修改，不会影响全局中同名的变量。如果函数内没有使用var关键字声明变量，则会设置为全局变量，对其进行赋值修改，会影响全局中同名的变量**

## 14、变量、函数的提前声明

（1）变量的声明提前：

​      使用var关键字声明的变量，会在**所有的代码执行之前被声明（但是不会赋值）**，但是如果声明变量时不使用var关键字，则变量不会被声明提前

（2）函数的声明提前

​      使用**函数声明形式**创建的函数，它会在所有的代码执行之前就被创建，所以我们**可以在函数声明前来调用函数**

​      使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用，否则会报错： "Uncaught TypeError: undefined is not a function"

## 15、this指向

解析器在调用函数每次都会向函数内部传递进一个隐含的参数,这个隐含的参数就是this，this指向的是一个对象，
称为函数执行的 上下文对象，根据函数的调用方式的不同，this会指向不同的对象

   * 以方法的形式调用时，this就是调用方法的那个对象

   * 以函数的形式调用时，this永远都是window

   * 以构造函数的形式调用时，this是新创建的那个对象

   * 使用call和apply调用时，this是指定的那个对象

   * 在事件的响应函数中，响应函数是给谁绑定的this就是谁

   * **addEventListener()中的this，是绑定事件的对象；attachEvent()中的this，是window**

     改变this的指向：在匿名函数中使用call和apply调用函数

### 改变this的指向：

在匿名函数中使用call和apply调用函数

```
	obj.attachEvent("on"+eventStr , function(){
						//在匿名函数中调用回调函数
						callback.call(obj);
					});
```

## 16、instanceof

使用instanceof可以检查一个对象是否是一个类的实例

语法：

​          对象 instanceof 构造函数       如果是，则返回true，否则返回false

 所有的对象都是Object的后代，所以任何对象和Object左instanceof检查时都会返回true//console.log(dog instanceof Object);

## 17、in运算符和hasOwnProperty

**in运算符**

通过该运算符可以检查一个对象中是否含有指定的属性，如果有则返回true，没有则返回false。如果对象中没有但是原型中有，也会返回true

语法：

​         “属性名" in 对象

**hasOwnProperty**

检查对象自身中是否含有该属性，使用该方法只有当对象自身中含有属性时，才会返回true

语法：

​          对象.hasOwnProperty("属性名"))

## 18、读取数组中不存在的索引

如果读取不存在的索引，他不会报错而是返回undefined

## 19、枚举对象中的属性

语法：
		for(var 变量 in 对象){}

 for...in语句 对象中有几个属性，循环体就会执行几次，每次执行时，会将对象中的一个属性的名字赋值给变量

```
		for(var n in obj){
			console.log("属性名:"+n);
			
			console.log("属性值:"+obj[n]);
		}
```

## 20、遍历数组的几种方法

**1、for循环**

**2、forEach()**

 这个方法只支持IE8以上的浏览器，IE8及以下的浏览器均不支持该方法，所以如果需要兼容IE8，则不要使用forEach，还是使用for循环来遍历

 forEach()方法需要一个函数作为参数
   * 像这种函数，由我们创建但是不由我们调用的，我们称为回调函数

   * 数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以来定义形参，来读取这些内容

   * 浏览器会在回调函数中传递三个参数：

      * 第一个参数，就是当前正在遍历的元素

      * 第二个参数，就是当前正在遍历的元素的索引

      * 第三个参数，就是正在遍历的数组

        ```
        	arr.forEach(function(value , index , obj){
        				console.log(value);//值
        				console.log(index);
        				console.log(obj);
        			})
        ```

## 21、函数的方法call和apply

 这两个方法都是**函数对象**的方法，需要通过函数对象来调用
   * 当对函数调用call()和apply()都会调用函数执行(和直接调用函数不同的是可以改变this的指向)

   * 在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this

   * call()方法可以将实参在对象之后依次传递

   * apply()方法需要将实参封装到一个数组中统一传递

     ```
     		function fun(a,b) {
     				console.log("a = "+a);
     				console.log("b = "+b);
     				alert(this.name);
     			}
     			
     			var obj = {
     				name: "obj",
     				sayName:function(){
     					alert(this.name);
     				}
     			};
     
             fun.call(obj,2,3);
             fun.apply(obj,[2,3]);
     ```

## 22、函数调用时，传递的参数

   * 1.函数的上下文对象 this

   * 2.封装实参的对象 arguments

     arguments是一个**类数组对象**,它也可以通过索引来操作数据，也可以用arguments.length来获取实参的长度

     在调用函数时，我们所传递的实参都会在arguments中保存

     **我们即使不定义形参，也可以通过arguments来使用实参，**

      * 只不过比较麻烦
     
      * arguments[0] 表示第一个实参
     
      * arguments[1] 表示第二个实参 。。。
     
      * 它里边有一个属性叫做callee，
     
      * 这个属性对应一个函数对象，就是当前正在指向的函数的对象
     
        ```
           function fun(a, b) {
                console.log(arguments instanceof Array); //false
                console.log(Array.isArray(arguments)); //false
                //console.log(arguments[1]);
                //console.log(arguments.length);
                console.log(arguments.callee == fun); //true
              }
        ```

## 23、字符串的方法

 在底层字符串是以字符数组的形式保存的

**length属性**
可以用来获取**字符串**的长度

**charAt()**
可以返回字符串中指定位置的**字符**，根据索引获取指定的字符

**charCodeAt()**
获取指定位置字符的**字符编码**（Unicode编码）

**String.formCharCode()**
可以根据字符编码去获取**字符**

```
result = String.fromCharCode(0x2692);
```

**concat()**
可以用来连接两个或多个**字符串**，作用和+一样

```
result = str.concat("你好","再见");
```

**indexof()**

该方法可以检索一个字符串中是否含有指定内容
   * 	如果字符串中含有该内容，则会返回其第一次出现的索引，如果没有找到指定的内容，则返回-1
   * 	可以指定一个第二个参数，指定开始查找的位置

**lastIndexOf()**

该方法的用法和indexOf()一样，不同的是indexOf是从前往后找，而lastIndexOf是从后往前找，也可以指定开始查找的位置

 **slice()**
可以从字符串中截取指定的内容，不会影响原字符串，而是将截取到内容返回
参数：
			第一个，开始位置的索引（包括开始位置）
			 第二个，结束位置的索引（不包括结束位置），如果省略第二个参数，则会截取到后边所有的
			 也可以传递一个负数作为参数，负数的话将会从后边计算

**substring()**

可以用来截取一个字符串，可以slice()类似
参数：
			第一个：开始截取位置的索引（包括开始位置）
			第二个：结束位置的索引（不包括结束位置）
			不同的是这个方法不能接受负值作为参数，如果传递了一个负值，则默认使用0
			而且他还自动调整参数的位置，如果第二个参数小于第一个，则自动交换

**substr()**
用来截取字符串
参数：
			1.截取开始位置的索引
			2.截取的长度

**split()**
可以将一个字符串拆分为一个数组
参数：
			需要一个字符串作为参数，将会根据该字符串去拆分

```
str = "abcbcdefghij";
result = str.split("d");
```

如果传递一个空串作为参数，则会将每个字符都拆分为数组中的一个元素    result = str.split("");

 **toUpperCase()**
将一个字符串转换为大写并返回

**toLowerCase()**
将一个字符串转换为小写并返回

## 24、innerHTML、innerText

1、 innerHTML

用于获取**元素内部的HTML代码**的（标签对象内部代码），对于自结束标签，这个属性没有意义，自结束标签没有内部代码

2、innerText

该属性可以获取到**元素内部的文本内容**，它和innerHTML类似，不同的是它会**自动将html标签去除**

## 25、取消事件默认行为

1、给响应函数添加return false

```
allA[i].onclick = function(event){
				return false;	
	};
```

2、

```
<a href="javascript:;">Delete</a>
```

3、event.preventDefault()

使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false，需要使用event来取消默认行为event.preventDefault();但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错

```
	box1.onmousewheel = function(event){
					event = event || window.event;
					event.preventDefault && event.preventDefault();			
					return false;
				};
```

4、setCapture()

ie8取消关于鼠标事件的默认行为

当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，这个个是浏览器提供的默认行为，如果不希望发生这个行为，则可以通过return false来取消默认行为，但是这招对IE8不起作用

方法：setCapture()当调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上

​            - 只有IE支持，但是在火狐中调用时不会报错而如果使用chrome调用，会报错

```
     *///设置box1捕获所有鼠标按下的事件

​          /*if(box1.setCapture){

​            box1.setCapture();

​          }*/

​          obj.setCapture && obj.setCapture();
```

```
//当鼠标松开时，取消对事件的捕获
						obj.releaseCapture && obj.releaseCapture();
```



## 26、添加事件监听器

同时为一个元素的**一个事件绑定多个响应函数**

1、 addEventListener()
	通过这个方法也可以为元素绑定响应函数

​    参数：

- 事件的字符串，不要on

- 回调函数，当事件触发时该函数会被调用

- 是否在捕获阶段触发事件，需要一个布尔值，一般都传false

  使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会**按照函数的绑定顺序执行**。**this指向绑定响应函数的对象**

  **注意：这个方法不支持IE8及以下的浏览器**

  使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false，需要**使用event来取消默认行为event.preventDefault()**;但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错

2、attachEvent()
	在IE8中可以使用attachEvent()来绑定事件
	参数：

   * 事件的字符串，要on

   * 回调函数

     这个方法也可以同时为一个事件绑定多个处理函数，不同的是它是**后绑定先执行**，执行顺序和addEventListener()相反。**this指向window**

3、解决兼容问题

```
		//定义一个函数，用来为指定元素绑定响应函数
			/*
			 * addEventListener()中的this，是绑定事件的对象
			 * attachEvent()中的this，是window
			 *  需要统一两个方法this
			 */
			/*
			 * 参数：
			 * 	obj 要绑定事件的对象
			 * 	eventStr 事件的字符串(不要on)
			 *  callback 回调函数
			 */
			function bind(obj , eventStr , callback){
				if(obj.addEventListener){
					//大部分浏览器兼容的方式
					obj.addEventListener(eventStr , callback , false);
				}else{
					/*
					 * this是谁由调用方式决定
					 * callback.call(obj)
					 */
					//IE8及以下
					obj.attachEvent("on"+eventStr , function(){
						//在匿名函数中调用回调函数
						callback.call(obj);
					});
				}
			}
```

**7、运算符的优先级**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201215092456122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NtbF9s,size_16,color_FFFFFF,t_70)

# 技巧

## 1、去除数组中重复的数字

```
	//创建一个数组
			var arr = [1,2,3,2,2,1,3,4,2,5];
			
			//去除数组中重复的数字
			for(var i=0 ; i<arr.length ; i++){
				for(var j=i+1 ; j<arr.length ; j++){
					if(arr[j]==arr[i]){
						// arr.pop(arr[j]);
						arr.splice(j,1);
						j--;
					}
				}
			}
			console.log(arr);
```



# 数据类型

在JS中一共有六种数据类型

   *      String 字符串
   *      Number 数值
   *      Boolean 布尔值
   *      Null 空值
   *      Undefined 未定义
   *      Object 对象

其中String Number Boolean Null Undefined属于基本数据类型。而Object属于引用数据类型

## string

​     \*  - 在JS中字符串需要使用引号引起来

​     \*  - 使用双引号或单引号都可以，但是不要混着用

​     *  - 引号不能嵌套，双引号不能放双引号，单引号不能放单引号

  在字符串中我们可以使用\作为转义字符，当表示一些特殊符号时可以使用\进行转义

​         \ \" 表示 "

​          \\' 表示 '

​          \n 表示换行

​          \t 制表符

​          \\ 表示\

# 运算符

## 算术运算符

 当对非Number类型的值进行运算时，会将这些值转换为Number然后在运算

**+**

+可以对两个值进行加法运算，并将结果返回

如果对两个字符串进行加法运算，则会做拼串，会将两个字符串拼接为一个字符串，并返回

**任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作**

**-**

可以对两个值进行减法运算，并将结果返回

*

可以对两个值进行乘法运算

/

 可以对两个值进行除法运算

%

% 取模运算（取余数）

  **任何值和字符串相加都会转换为字符串，并做拼串操作**

​    \* 我们可以利用这一特点，来将一个任意的数据类型转换为String

​    \*   我们只需要为任意的数据类型 + 一个 "" 即可将其转换为String

​    \*   这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数

**任何值做- * /运算时都会自动转换为Number**

  我们可以利用这一特点做隐式的类型转换，可以通过为一个值 -0 *1 /1来将其转换为Number，原理和Number()函数一样，使用起来更加简单

## 一元运算符

一元运算符，只需要一个操作数

正号不会对数字产生任何影响

负号可以对数字进行负号的取反

 * 对于非Number类型的值，它会将先转换为Number，然后在运算
 * **可以对一个其他的数据类型使用+,来将其转换为number，它的原理和Number()函数一样**

## 自增和自减

自增 ++

可以使变量在自身的基础上增加1

   * 对于一个变量自增以后，原变量的值会立即自增1

   * 自增分成两种：后++(a++) 和 前++(++a)   

     无论是a++ 还是 ++a，都会**立即使原变量的值自增1**

     不同的是a++ 和 ++a的值不同

     **a++的值等于原变量的值（自增前的值）**

     **++a的值等于新值 （自增后的值）**

自减 --

通过自减可以使变量在自身的基础上减1

* 自减分成两种：后--(a--) 和 前--(--a)

  无论是a-- 还是 --a 都会**立即使原变量的值自减1**

* 不同的是a-- 和 --a的值不同

  a-- 是变量的原值 （自减前的值）

  --a 是变量的新值 （自减以后的值）

## 逻辑运算符

### 布尔值

JS中为我们提供了三种逻辑运算符

​        **!非**

   * 所谓非运算就是值对一个布尔值进行取反操作，true变false，false变true

     如果对一个值进行两次取反，它不会变化

     如果对非布尔值进行元素，则会将其转换为布尔值，然后再取反，所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值

 * **可以为一个任意数据类型取两次反，来将其转换为布尔值，原理和Boolean()函数一样**

   **&& 与**

 * &&可以对符号两侧的值进行与运算并返回结果

 * 运算规则

   两个值中只要有一个值为false就返回false，

   只有两个值都为true时，才会返回true

   如果第一个值为false，则不会看第二个值

   **|| 或**

 * ||可以对符号两侧的值进行或运算并返回结果

 * 运算规则：

   两个值中只要有一个true，就返回true

   如果两个值都为false，才返回false

   JS中的“或”属于短路的或，如果第一个值为true，则不会检查第二个值

### 非布尔值

&& || 非布尔值的情况
  - 对于非布尔值进行与或运算时，
       * **会先将其转换为布尔值，然后再运算，并且返回原值**
       
       * 与运算：
       
         如果第一个值为true，则必然返回第二个值
       
         如果第一个值为false，则直接返回第一个值
       
       * 或运算
       
         如果第一个值为true，则直接返回第一个值

## 赋值运算符

## 关系运算符

        * 通过关系运算符可以比较两个值之间的大小关系，
             * 如果关系成立它会返回true，如果关系不成立则返回false
             
             * > 大于号
             
             * - 判断符号左侧的值是否大于右侧的值
             
             * - 如果关系成立，返回true，如果关系不成立则返回false
             
             * >= 大于等于
             
             * - 判断符号左侧的值是否大于或等于右侧的值
             
             * < 小于号
             
             * <= 小于等于
             
             * **任何值和NaN做任何比较都是false**
             
             * 非数值的情况
             
               对于非数值进行比较时，会将其转换为数字然后在比较
             
               如果符号两侧的值都是字符串时，不会将其转换为数字进行比较（比较数字字符串会得到意外的结果），而会分别比较字符串中字符的Unicode编码

## 相等运算符

相等运算符用来比较两个值是否相等， 如果相等会返回true，否则返回false

（1）==相等 

​      当使用==来比较两个值时，如果值的类型不同，则会**自动进行类型转换**，将其转换为相同的类型，然后在比较

（2）！=不相等

​      不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false，不相等也会对变量进行**自动的类型转换**，如果转换后相等它也会返回false

（3）===全等

​       用来判断两个值是否全等，它和相等类似，不同的是它**不会做自动的类型转换**，如果两个值的类型不同，直接返回false

（4）!==不全等

​      用来判断两个值是否不全等，和不等类似，不同的是它**不会做自动的类型转换**，如果两个值的类型不同，直接返回true

```
/*
       * undefined 衍生自 null
       * 	所以这两个值做相等判断时，会返回true
*/
      console.log(undefined == null);true
      console.log(null === undefined);//false
```

​    **NaN不和任何值相等，包括他本身**

​    当比较两个基本数据类型的值时，就是比较值。而比较两个引用数据类型时，它是比较的对象的内存地址， 如果两个对象是一摸一样的，但是地址不同，它也会返回false

# 对象

对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。

## 对象的分类

1.内建对象

由ES标准中定义的对象，在任何的ES的实现中都可以使用；比如：Math String Number Boolean Function Object....

2.宿主对象

由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象；比如 BOM DOM

3.自定义对象

由开发人员自己创建的对象

## 创建对象

### 1、使用object创建对象

```
		/*
			 * 使用new关键字调用的函数，是构造函数constructor
			 * 	构造函数是专门用来创建对象的函数
			 * 使用typeof检查一个对象时，会返回object
			 */
			var obj = new Object();
			
```

### 2、使用对象字面量创建对象

```
var obj = {};
```

  使用对象字面量，可以在创建对象时，直接指定对象中的属性

​       语法：{属性名:属性值,属性名:属性值....}

​       **对象字面量的属性名可以加引号也可以不加，建议不加,如果要使用一些特殊的名字，则必须加引号**

### 3、使用工厂方法创建对象

通过该方法可以大批量的创建对象

```
			function createPerson(name , age ,gender){
				//创建一个新的对象 
				var obj = new Object();
				//向对象中添加属性
				obj.name = name;
				obj.age = age;
				obj.gender = gender;
				obj.sayName = function(){
					alert(this.name);
				};
				//将新的对象返回
				return obj;
			}
```

 使用工厂方法创建的对象，实质上使用的构造函数都是Object ，创建的对象都是Object这个类型，就导致我们**无法区分出多种不同类型的对象**

### 4、 创建构造函数

构造函数和普通函数的区别：

(1)构造函数习惯上首字母大写

(2)构造函数和普通函数的区别就是调用方式的不同, 普通函数是直接调用，而构造函数需要使用new关键字来调用

构造函数的执行流程：
       1.立刻创建一个新的对象
       2.将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象
       3.逐行执行函数中的代码
        使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。我们将通过一个构造函数创建的对象，称为是该类的实例

```
      function Person(name, age, gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
        this.sayName = function () {
          alert(this.name);
        };
      }
```

## 对象属性的增删改查

 1、 向对象添加属性

​       语法：对象.属性名 = 属性值;

  2、读取对象中的属性

​       语法：对象.属性名

​       **如果读取对象中没有的属性，不会报错而是会返回undefined**

  3、修改对象的属性值

​        语法：对象.属性名 = 新值

  4、删除对象的属性

​        语法：delete 对象.属性名

5、对象的属性值可以是任何的数据类型，也可以是个函数

	 * 	如果一个函数作为一个对象的属性保存，
	 * 	那么我们称这个函数时这个对象的方法
	 * 	调用这个函数就说调用对象的方法（method）

## 特殊的属性名

如果要使用特殊的属性名，不能采用.的方式来操作

需要使用另一种方式：语法：对象["属性名"] = 属性值，读取时也需要采用这种方式，使用[]这种形式去操作属性，更加的灵活，**在[]中可以直接传递一个变量，这样变量值是多少就会读取那个属性**

```
   obj["123"] = 789;
      obj["nihao"] = "你好";
      var n = "nihao";
       console.log(obj[n]);
```

## in 运算符

通过该运算符可以检查一个对象中是否含有指定的属性，如果有则返回true，没有则返回false

语法：

“属性名" in 对象

## 枚举对象中的属性

语法：
		for(var 变量 in 对象){}

 for...in语句 对象中有几个属性，循环体就会执行几次，每次执行时，会将对象中的一个属性的名字赋值给变量

			for(var n in obj){
				console.log("属性名:"+n);
				
				console.log("属性值:"+obj[n]);
			}

## 基本类型和引用类型的存储位置

**基本数据类型**在栈内存中存储，变量保存的是值，值与值之间是独立存在，修改一个变量不会影响其他的变量

**引用数据类型**是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响

# 函数

   函数也是一个对象

​      函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）

​      **使用typeof检查一个函数对象时，会返回function**

## 创建函数

### 1、使用构造函数创建函数对象

```
//可以将要封装的代码以字符串的形式传递给构造函数
			var fun = new Function("console.log('Hello 这是我的第一个函数');");
```

### 2、使用函数声明创建函数

 语法：

​        function 函数名([形参1,形参2...形参N]){

​         语句...

​        }

```
		function fun2(){
				console.log("这是我的第二个函数~~~");
				alert("哈哈哈哈哈");
				document.write("~~~~(>_<)~~~~");
			}
```

### 3、使用函数表达式创建函数

  var 函数名  = function([形参1,形参2...形参N]){

   语句....

​        }

```
	var fun3 = function(){
				console.log("我是匿名函数中封装的代码");
			};
```

## 调用函数

语法：函数对象()

 当调用函数时，函数中封装的代码会按照顺序执行

```
    //打出函数的内容
    console.log(fun2);
	//调用fun2
	//fun2();
```

#### 形参

  可以在函数的()中来指定一个或多个形参（形式参数）

  多个形参之间使用,隔开，声明形参就相当于在**函数内部声明了对应的变量但是并不赋值**

#### **实参**

**1、调用函数时解析器不会检查实参的类型**

所以要注意，是否有可能会接收到非法的参数，如果有可能则**需要对参数进行类型的检查**

**2、 调用函数时，解析器也不会检查实参的数量**

​       多余实参不会被赋值

​       如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined

**3、实参可以是任意的数据类型，可以是一个对象，也可以是一个函数**

##  return 返回值

 	return后的值将会会作为函数的执行结果返回，
 			 * 	可以定义一个变量，来接收该结果
 			 * 
 			 *  在函数中return后的语句都不会执行
 			 * 
 			 * 	如果return语句后不跟任何值就相当于返回一个undefined，
 			 * 	如果函数中不写return，则也会返回undefined
 			 * 
 			 * 	return后可以跟任意类型的值

**如果return语句后不跟任何值就相当于返回一个undefined，如果函数中不写return，则也会返回undefined**

 return可以结束整个函数，后面的代码将不在执行

##  立即执行函数

	       /*
			 * 	函数定义完，立即被调用，这种函数叫做立即执行函数
			 * 	立即执行函数往往只会执行一次
			 */
			/*(function(){
				alert("我是一个匿名函数~~~");
			})();*/
			
			(function(a,b){
				console.log("a = "+a);
				console.log("b = "+b);
			})(123,456);

# 原型对象

我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应着一个对象，这个对象就是我们所谓的原型对象

   * 如果函数作为普通函数调用prototype没有任何作用

   * 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性_proto_，指向该构造函数的原型对象**prototype**，**对象可以通过proto来访问构造函数的prototype属性**（指向的地址相同）

     ```
     console.log(mc2.__proto__ == MyClass.prototype);//true 对象进行比较时，比较的是地址
     ```

   * 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象。可以将这些**对象共有的属性和方法，统一添加到构造函数的原型对象中**，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法

   * **当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用**

   * **原型对象也是对象，所以它也有原型proto，**

     当我们使用一个对象的属性或方法时，会现在自身中寻找，自身中如果有，则直接使用，如果没有则去原型对象中寻找，如果原型对象中有，则使用，如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型（null），如果在Object原型中依然没有找到**，则返回undefined**

# 垃圾回收

在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，

​       \*    我们不需要也不能进行垃圾回收的操作

​       \*  - 我们需要做的只是要将不再使用的对象设置null即可

# 数组

**数组也是一个对象**，它和我们普通对象功能类似，也是用来存储一些值的，不同的是普通对象是使用字符串作为属性名的，，而数组使用数字来作为索引操作元素

**使用typeof检查一个数组时，会返回object**

数组中的元素可以是任意的数据类型，可以是对象，可以是一个函数，数组中也可以放数组，如下这种数组我们称为二维数组

```
	arr = [[1,2,3],[3,4,5],[5,6,7]];
```

## 创建数组对象

### 1、使用Array创建数组

```
var arr = new Array();
//创建一个长度为10的数组
var arr2 = new Array(10);
```

可以同时添加元素，将要添加的元素作为构造函数的参数传递

```
var arr2 = new Array(10,20,30);
```

### 2、使用字面量来创建数组

语法:[]
使用字面量创建数组时，可以在创建时就指定数组中的元素

```
var arr = [1,2,3,4,5,10];
```

## 数组的增改查

1、向数组中**修改**元素

​      语法：数组[索引] = 值

2、 **读取**数组中的元素

​       语法：数组[索引]

​       **如果读取不存在的索引，他不会报错而是返回undefined**

3、**获取**数组的长度(元素的个数)

​      语法：数组.length

​      对于连续的数组，使用length可以获取到数组的长度（**元素的个数**），对于非连续的数组，使用length会获取到数组的**最大的索引           +1**，尽量不要创建非连续的数组

4、修改length

```
arr.length = 10;
```

​      如果修改的length大于原长度，则多出部分会空出来。如果修改的length小于原长度，则多出的元素会被删除

5、向数组的最后一个位置**添加**元素

​      语法：数组[数组.length] = 值;

## 数组的方法

**push()**

该方法可以向数组的末尾添加一个或多个元素，将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾，并将数组新的长度作为返回值返回

```
var result = arr.push("唐僧","蜘蛛精","白骨精","玉兔精");
```

**pop()**

该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回

```
result = arr.pop();
```

**unshift()**

向数组开头添加一个或多个元素，并返回新的数组长度，向前边插入元素以后，其他的元素索引会依次调整

```
arr.unshift("牛魔王","二郎神");
```

**shift()**

可以删除数组的第一个元素，并将被删除的元素作为返回值返回

```
result = arr.shift();
```

**splice()**

可以用于删除数组中的指定元素，使用splice(**)会影响到原数组**，会将指定元素从原数组中删除，并将被删除的元素作为返回值返回

参数：
			 * 		第一个，表示开始位置的索引，,**包含开始索引**

   * 		第二个，表示删除的数量
   * 		第三个及以后。。可以传递一些新的元素，这些元素将会**自动插入到开始位置索引前边**

```
var result = arr.splice(3,0,"牛魔王","铁扇公主","红孩儿");
```

**利用该方法可以向数组指定的位置添加元素**

**reverse（）**

该方法用来反转数组（前边的去后边，后边的去前边），该方法会**直接修改原数组**

```
arr.reverse();
```

**sort()**

可以用来对数组中的元素进行排序，也**会影响原数组**，默认会**按照Unicode编码进行排序**

```
arr.sort();
```

**即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，所以对数字进排序时，可能会得到错误的结果。**
 我们可以自己来指定排序的规则

   * 我们可以在sort()添加一个回调函数，来指定排序规则，回调函数中需要定义两个形参,浏览器将会分别使用数组中的元素作为实参去调用回调函数

   * 使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边

   * 浏览器会根据回调函数的返回值来决定元素的顺序，

      * 如果返回一个大于0的值，则元素会交换位置

      * 如果返回一个小于0的值，则元素位置不变

      * 如果返回一个0，则认为两个元素相等，也不交换位置

      * 如果需要升序排列，则返回 a-b

      * 如果需要降序排列，则返回b-a

        ```
        			arr.sort(function(a,b){
        				
        				//前边的大
        				/*if(a > b){
        					return -1;
        				}else if(a < b){
        					return 1;
        				}else{
        					return 0;
        				}*/
        				
        				//升序排列
        				//return a - b;
        				
        				//降序排列
        				return b - a;
        				
        			})
        ```

**以上方法都会直接影响原数组**

**slice()**

可以用来从数组提取指定元素，该方法**不会改变元素数组**，而是将截取到的元素封装到一个新数组中返回

参数：

 * 		截取开始的位置的索引,**包含开始索引**
 * 		截取结束的位置的索引,不包含结束索引，第二个参数可以省略不写,此时会截取从开始索引往后的所有元素
 * 		索引可以传递一个负值，如果传递一个负值，则从后往前计算
      * 			-1 倒数第一个
      * 			-2 倒数第二个

```
var result = arr.slice(1,4);
```

**concat()**

可以连接两个或多个数组，并将新的数组返回，该方法**不会对原数组产生影响**

```
	var result = arr.concat(arr2,arr3,"牛魔王","铁扇公主");
```

**join()**

该方法可以将数组转换为一个字符串，该方法**不会对原数组产生影响**，而是将转换后的字符串作为结果返回

 * 	在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符
 * 	如果不指定连接符，则默认使用,（逗号）作为连接符

```
result = arr.join("@-@");
```

数组的forEach、some、every、filter、map、find、from、includes、findIndex照这么说都是哦

# Date对象

 在JS中使用Date对象来表示一个时间

	//如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间
	var d = new Date();
	//创建一个指定的时间对象
	//需要在构造函数中传递一个表示时间的字符串作为参数
	//日期的格式  月份/日/年 时:分:秒
	var d2 = new Date("2/18/2011 11:10:30");

## data对象的方法

**getDate()**
	获取当前日期对象是几日

```
var date = d2.getDate();
```

**getDay()**
 获取当前日期对象时周几，会返回一个0-6的值，0 表示周日，1表示周一

```
var day = d2.getDay();
```

 **getMonth()**

获取当前时间对象的月份，会返回一个0-11的值，表示1月,1 表示2月,11 表示12月

```
var month = d2.getMonth();
```

**getFullYear()**
获取当前日期对象的年份

```
var year = d2.getFullYear();
```

**getTime()**

 获取当前日期对象的时间戳
时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒,到当前日期所花费的毫秒数（1秒 = 1000毫秒）
**计算机底层在保存时间时使用都是时间戳**

# Math对象

Math和其他的对象不同，它不是一个构造函数，它属于**一个工具类不用创建对象**，它里边封装了数学运算相关的属性和方法

## Math的方法

**PI**

Math.PI 表示的圆周率

**abs()**

可以用来计算一个数的绝对值

**Math.ceil()**
可以对一个数进行向上取整，小数位只有有值就自动进1

**Math.floor()**

可以对一个数进行向下取整，小数部分会被舍掉

**Math.random()**
可以用来生成一个**0-1**之间的随机数

生成一个0-x之间的随机数：Math.round(Math.random()*x)

生成一个x-y之间的随机数：Math.round(Math.random()*(y-x)+x)

**max()**

可以获取多个数中的最大值

```
var max = Math.max(10,45,30,100);
```

 **min()** 

可以获取多个数中的最小值

```
var min = Math.min(10,45,30,100);
```

**Math.pow(x,y)**

返回x的y次幂

**Math.sqrt()**

用于对一个数进行开方运算

# 正则表达式

用于定义一些字符串的规则，计算机可以根据**正则表达式，来检查一个字符串是否符合规则，将字符串中符合规则的内容提取出来**

 使用typeof检查正则对象，会返回object

## 创建正则表达式的对象

### 1、使用RegExp创建对象

语法：
		var 变量 = new RegExp("正则表达式","匹配模式");

在构造函数中可以传递一个匹配模式作为第二个参数，可以是 i 忽略大小写 ，g 全局匹配模式

**可以为一个正则表达式设置多个匹配模式，且顺序无所谓**

### 2、使用字面量来创建正则表达式

​	语法：var 变量 = /正则表达式/匹配模式

```
//var reg = new RegExp("a","i");		
var reg = /a/i;
```

## 正则表达式的方法

**test()**
使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false

```
	var reg = new RegExp("ab","i");
	var result = reg.test(str);
```

## 应用

1、创建一个正则表达式，检查一个字符串中是否有a**或**b

​      **使用 | 表示或者的意思**   

```
reg = /a|b|/;
```

2、创建一个正则表达式检查一个字符串中是否有字母
	[]里的内容也是**或**的关系
	[ab] == a|b
	 [a-z] 任意小写字母
	 [A-Z] 任意大写字母
	 [A-z] 任意字母
	 [0-9] 任意数字

```
	reg = /[A-z]/;
	//检查一个字符串中是否含有 abc 或 adc 或 aec
	reg = /a[bde]c/;
```

 3、除了它们之外，字符串还有别的字符就返回true。

```
reg = /[^ab]/;
```

4、量词

通过量词可以设置一个内容出现的次数
	 量词**只对它前边的一个内容起作用**

```
{n} 正好出现n次
			 * 	- {m,n} 出现m-n次
			 * 	- {m,} m次以上
			 * 	- + 至少一个，相当于{1,}
			 * 	- * 0个或多个，相当于{0,}
			 * 	- ? 0个或1个，相当于{0,1}
			reg = /(ab){3}/;//ababab
			reg = /b{3}/;//bbb
			reg = /ab{1,3}c/;//abc,abbc,abbbc
			//ababab			
			reg = /ab+c/;			
			reg = /ab*c/;			
			reg = /ab?c/;
```

5、检查一个字符串中是否以a开头

^ 表示开头

$ 表示结尾

```
	reg = /^a/; //匹配开头的a
	reg = /a$/; //匹配结尾的a
	reg = /^a$/;//以a开头同时这个相同的a还是结尾
	reg = /^a|a$/;//以表达式开头或结尾都会返回true
```

## 字符串和正则相关的方法

**split()**

可以将一个字符串拆分为一个数组

方法中可以传递一个正则表达式作为参数，这样方法将会**根据正则表达式去拆分字符串**，这个方法**即使不指定全局匹配，也会全都插分**

			/*
			 * 根据任意字母来将字符串拆分
			 */
			var result = str.split(/[A-z]/);

 **search()**

可以搜索字符串中是否含有指定内容，如果搜索到指定内容，则会返回第一次出现的第一个字符的索引，如果没有搜索到返回-1

* 返回第一个符合要求的内容的第一个字符的索引，

 * 它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串

 * serach()只会查找第一个，即使**设置全局匹配也没用**

   ```
   	str = "hello abc hello aec afc";
   			/*
   			 * 搜索字符串中是否含有abc 或 aec 或 afc
   			 */
   	result = str.search(/a[bef]c/);
   ```

 **match()**

根据正则表达式，从字符串中将符合条件的内容提取出来

**默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索**

* 		我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容
 * 		可以为一个正则表达式设置多个匹配模式，且顺序无所谓
 * 	**match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果**

```
			str = "1a2a3a4a5e6f7A8B9C";
			result = str.match(/[a-z]/ig);
```

 **replace()**

将字符串中指定内容替换为新的内容

参数：

 * 		被替换的内容，可以接受一个正则表达式作为参数
 * 		新的内容
 *  默认只会替换第一个
 * 		**不会影响原数组**

		*///result = str.replace(/[a-z]/gi , "@_@");
		result = str.replace(/[a-z]/gi , "");
		console.log(str);
		 console.log(result);

# DOM

## 什么是DOM

 DOM，全称Document Object Model文档对象模型。
 JS中通过DOM来对HTML文档进行操作。只要理解了DOM就可以随心所欲的操作WEB页面。
• 文档
– 文档表示的就是整个的HTML网页文档
• 对象
– 对象表示将网页中的每一个部分都转换为了一个对象。
• 模型
– **使用模型来表示对象之间的关系，这样方便我们获取对象。**

浏览器已经为我们提供文档节点对象，这个对象是window的属性，可以在页面中直接使用，文档节点代表的是整个网页，通过它可以沿着模型找其他的对象

![image-20221128154154758](C:\Users\ydy\AppData\Roaming\Typora\typora-user-images\image-20221128154154758.png)



## 节点

节点Node，是构成我们网页的最基本的组成部分，网页中的每一个部分都可以称为是一个节点,就是对象。 比如：html标签、属性、文本、注释、整个文档等都是一个节点。
节点：Node——构成HTML文档最基本的单元。
常用节点分为四类
– 文档节点：整个HTML文档
– 元素节点：HTML文档中的HTML标签
– 属性节点：元素的属性
– 文本节点：HTML标签中的文本内容

![image-20221128154359276](C:\Users\ydy\AppData\Roaming\Typora\typora-user-images\image-20221128154359276.png)

**四种对象**

### 节点的属性

![image-20221128154635352](C:\Users\ydy\AppData\Roaming\Typora\typora-user-images\image-20221128154635352.png)

**nodeType可以用来判断是什么节点**

### 获取节点对象的几种方法

####  获取元素节点

通过**document**对象调用

1、getElementById  根据id属性值

```
var btn01 = document.getElementById("btn01");
```

2、getElementsByTagName()    根据标签名来获取**一组**元素节点对象

这个方法会给我们返回一个**类数组对象**，所有查询到的元素都会封装到对象中，即使查询到的元素只有一个，也会封装到数组中返回

```
var lis = document.getElementsByTagName("li");
```

3、getElementsByName     根据name属性值

这个方法会给我们返回一个**类数组对象**，所有查询到的元素都会封装到对象中，即使查询到的元素只有一个，也会封装到数组中返回

```
		<div class="inner">
				gender:
				<input class="hello" type="radio" name="gender" value="male"/>
				Male
				<input class="hello" type="radio" name="gender" value="female"/>
				Female
				<br>
				<br>
				name:
				<input type="text" name="name" id="username" value="abcde"/>
			</div>
         var inputs = document.getElementsByName("gender");
```

4、getElementsByClassName      根据元素的class属性值查询**一组元素节点对象**，**但是该方法不支持IE8及以下的浏览器**

```
var box1 = document.getElementsByClassName("box1");
```

5、querySelector()       根据一个**CSS选择器**来查询**一个元素节点对象**

 虽然IE8中没有getElementsByClassName()，但是可以使用querySelector()代替， 使用该方法总会返回**唯一的一个元素**，如果满足条件的元素有多个，那么它只会返回第一个

```
var div = document.querySelector(".box1 div");
```

6、querySelectorAll()

该方法和querySelector()用法类似，不同的是它会将**符合条件的元素封装到一个数组**中返回，即使符合条件的元素只有一个，它也会返回数组

```
	box1 = document.querySelectorAll(".box1");
//	box1 = document.querySelectorAll("#box2");
	console.log(box1[0].innerText);
```

#### 获取元素节点的子节点

 通过**具体的元素节点**调用
1. getElementsByTagName()
    – 方法，返回当前节点的指定标签名后代节点

2. childNodes   

  – 属性，表示当前节点的**所有子节点**，获取包括文本节点在内的所有节点，标签间空白也会当成文本节点

  注意：在IE8及以下的浏览器中，不会将空白文本当成子节点，所以该属性在IE8中会返回4个子元素而其他浏览器是9个

3. children

  children属性，可以获取当前元素的**所有子元素**(非子节点)

4. firstChild

  – 属性，表示当前节点的**第一个子节点**（包括空白文本节点）

5. firstElementChild

  获取当前元素的**第一个子元素**，不支持IE8及以下的浏览器，如果需要兼容他们尽量不要使用，如果使用返回undefined

6. lastChild
    – 属性，表示当前节点的最后一个子节点

7. parentNode

  – 属性，获取当前节点的**父亲元素**。空白文档在这里不被看做节点

8. previousSibling

  – 属性，返回当前节点的前一个兄弟节点（也可能获取到空白的文本）

9. previousElementSibling

  – 属性，获取前一个兄弟元素，IE8及以下不支持

10. nextSibling
    – 属性，表示当前节点的后一个兄弟节点

### 读取元素节点属性

语法：元素.属性名
例子：元素.id      元素.name          元素.value

注意：class属性不能采用这种方式，class是保留字，不能作为属性名，读取class属性时需要使用 元素.className

 nodeValue
– 文本节点可以通过nodeValue属性获取和设置**文本节点的内容**

```
bj.firstChild.nodeValue
bj.firstChild.nodeValue == bj.innerHTML //true
```

 innerHTML
– 元素节点通过该属性获取和设置标签内部的html代码

### dom的增删改

1、createElement（）

可以用于创建一个元素节点对象，它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回

```
//创建li元素节点
var li = document.createElement("li");
```

2、createTextNode()

可以用来创建一个文本节点对象
需要一个文本内容作为参数，将会根据该内容创建文本节点，并将新的节点返回

```
//创建广州文本节点
var gzText = document.createTextNode("广州");
```

3、appendChild()
向一个父节点中添加一个新的子节点

- 用法：父节点.appendChild(子节点);

  ```
  //将gzText设置li的子节点
  li.appendChild(gzText);
  //获取id为city的节点
  var city = document.getElementById("city");
  //将广州添加到city下
  city.appendChild(li);
  ```

4、insertBefore()

可以在指定的子节点前插入新的子节点
 *  语法：
	
	父节点.insertBefore(新节点,旧节点);
	
	```
		//创建一个广州
						var li = document.createElement("li");
						var gzText = document.createTextNode("广州");
						li.appendChild(gzText);			
						//获取id为bj的节点
						var bj = document.getElementById("bj");				
						//获取city
						var city = document.getElementById("city");
						city.insertBefore(li , bj);
	```

5、replaceChild()

 可以使用指定的子节点替换已有的子节点
		语法：父节点.replaceChild(新节点,旧节点);

```
city.replaceChild(li , bj);
```

5、removeChild()
可以删除一个子节点
		语法：父节点.removeChild(子节点);
					 子节点.parentNode.removeChild(子节点);

```
city.removeChild(bj);
bj.parentNode.removeChild(bj);
```

**注意： 使用innerHTML也可以完成DOM的增删改的相关操作， 一般我们会两种方式结合使用**

```
//city.innerHTML += "<li>广州</li>";
					//创建一个li
					var li = document.createElement("li");
					//向li中设置文本
					li.innerHTML = "广州";
					//将li添加到city中
					city.appendChild(li);
```

不要在父节点下直接innerHTML增加节点，它会对**整个子元素处理后，在重新赋值**。建议给父节点的儿子使用innerHTML添加节点，而父节点添加子节点依旧通过appendchild

## 文档的加载

浏览器是按照自上向下的顺序加载页面的，读取到一行就运行一行,如果将script标签写到页面的上边，在代码执行时，页面没有加载，DOM对象也没有加载，会导致无法获取到DOM对象

**解决办法**

onload事件会在整个页面加载完成之后才触发，为window绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，
这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了

```
	window.onload = function(){
				//获取id为btn的按钮
				var btn = document.getElementById("btn");
				//为按钮绑定一个单击响应函数
				btn.onclick = function(){
					alert("hello");
				};
			};
```

## 注意for循环

```

		//获取所有额超链接
		var allA = document.getElementsByTagName("a");
		
		//为每个超链接都绑定一个单击响应函数
		for(var i=0 ; i < allA.length ; i++){
			/*
			 * for循环会在页面加载完成之后立即执行，
			 * 	而响应函数会在超链接被点击时才执行
			 * 当响应函数执行时，for循环早已执行完毕
			 */
			
			alert("for循环正在执行"+i);
			
			allA[i].onclick = function(){
				
				alert("响应函数正在执行"+i);
				
				//alert(allA[i]);
				
				return false;
			};
			
```

## 事件

用户和浏览器之间的交互行为。	比如：点击按钮，鼠标移动、关闭窗口。。。

```
	
			//获取按钮对象
			var btn = document.getElementById("btn");
			
			/*
			 * 可以为按钮的对应事件绑定处理函数的形式来响应事件
			 * 	这样当事件被触发时，其对应的函数将会被调用
			 */
			
			//绑定一个单击事件
			//像这种为单击事件绑定的函数，我们称为单击响应函数
			btn.onclick = function(){
				alert("你还点~~~");
			};
```

(1)点击事件

onClick

(2)滚动条事件

onScroll

(3)该事件将会在鼠标在元素中移动时被触发

**有兼容性问题**

onmousemove

```
 * clientX可以获取鼠标指针的水平坐标
			 * cilentY可以获取鼠标指针的垂直坐标
			 */
//			除了ie8全都兼容
			var x = event.clientX;
			var y = event.clientY
```

（4）滚轮滚动的事件

**有兼容性问题**

onmousewheel、 DOMMouseScroll 

鼠标滚轮滚动的事件，会在滚轮滚动时触发，但是火狐不支持该属性。在火狐中需要使用 DOMMouseScroll 来绑定滚动事件，注意该事件需要通过addEventListener()函数来绑定

```
//event.wheelDelta 可以获取鼠标滚轮滚动的方向
//向上滚 120   向下滚 -120
//wheelDelta这个值我们不看大小，只看正负
//wheelDelta这个属性火狐中不支持
//在火狐中使用event.detail来获取滚动的方向
//向上滚 -3  向下滚 3
//alert(event.detail);
```

```
box1.onmousewheel = function(event){
					event = event || window.event;
					
					//event.wheelDelta 可以获取鼠标滚轮滚动的方向
					//向上滚 120   向下滚 -120
					//wheelDelta这个值我们不看大小，只看正负
					
					//alert(event.wheelDelta);
					
					//wheelDelta这个属性火狐中不支持
					//在火狐中使用event.detail来获取滚动的方向
					//向上滚 -3  向下滚 3
					//alert(event.detail);
					
					/*
					 * 当鼠标滚轮向下滚动时，box1变长
					 * 	当滚轮向上滚动时，box1变短
					 */
					//判断鼠标滚轮滚动的方向
					if(event.wheelDelta > 0 || event.detail < 0){
						//向上滚，box1变短
						box1.style.height = box1.clientHeight - 10 + "px";
						
					}else{
						//向下滚，box1变长
						box1.style.height = box1.clientHeight + 10 + "px";
					}
					
					/*
					 * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false
					 * 需要使用event来取消默认行为event.preventDefault();
					 * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错
					 */
					event.preventDefault && event.preventDefault();

					/*
					 * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，
					 * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为
					 */
					return false;			
				};
				//为火狐绑定滚轮事件
				bind(box1,"DOMMouseScroll",box1.onmousewheel);				
			};
```

（5）键盘事件
**onkeydown**

按键被按下

 * 		对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发
 * 		当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发

**onkeyup**

按键被松开
**键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document**

```
/*
					 * 可以通过keyCode来获取按键的编码
					 * 	通过它可以判断哪个按键被按下
					 * 除了keyCode，事件对象中还提供了几个属性
					 * 	altKey
					 * 	ctrlKey
					 * 	shiftKey
					 * 		- 这个三个用来判断alt ctrl 和 shift是否被按下
					 * 			如果按下则返回true，否则返回false
					 */
//获取input
				var input = document.getElementsByTagName("input")[0];
				
				input.onkeydown = function(event){
					
					event = event || window.event;
					
					//console.log(event.keyCode);
					//数字 48 - 57
					//使文本框中不能输入数字
					if(event.keyCode >= 48 && event.keyCode <= 57){
						//在文本框中输入内容，属于onkeydown的默认行为
						//如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中
						return false;
					}
					
					
				};
			};
			
```

### 事件对象

当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数,，在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标  键盘哪个按键被按下  鼠标滚轮滚动的方向。。。

在IE8中，响应函数被触发时，浏览器不会传递事件对象。在IE8及以下的浏览器中，是将事件对象作为window对象的属性保存的
 window.event火狐不兼容

**解决事件对象的兼容性问题**：

```
/*if(!event){
				event = window.event;
			}*/
			//解决事件对象的兼容性问题
			event = event || window.event;
```

### 事件的传播

				 * 	关于事件的传播网景公司和微软公司有不同的理解
	 * 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。
	
	 * 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后在向内传播给后代元素
	
	 * 	W3C综合了两个公司的方案，将事件传播分成了三个阶段
			
		1.捕获阶段
		
		在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件
		
		2.目标阶段
		
		事件捕获到目标元素，捕获结束开始在目标元素上触发事件
		
		3.冒泡阶段
		
		事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件。后代元素上的事件被触发时，其祖先元素的相同事件也会被触发（事件从目标元素向祖先元素，由里向外的一次触发相同事件）
		
		如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true，一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false
		
		**IE8及以下的浏览器中没有捕获阶段**
		
		**取消冒泡**
		
		```
		//取消冒泡
		//可以将事件对象的cancelBubble设置为true，即可取消冒泡
		event.cancelBubble = true;
		```

### 事件的委派

* 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。
* 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能

## 操作元素的样式

### 1、修改元素的样式

语法：元素.style.样式名 = 样式值

**注意：如果CSS的样式名中含有-，这种名称在JS中是不合法的比如background-color，需要将这种样式名修改为驼峰命名法，去掉-，然后将-后的字母大写**

**我们通过style属性设置**的样式都是**行内样式**，而内联样式有较高的优先级，所以通过JS修改的样式往往会立即显示

但是如果在样式中写了!important，则此时样式会有最高的优先级，即使通过JS也不能覆盖该样式，此时将会导致JS修改样式失效，所以尽量不要为样式添加!important

```
box1.style.width = "300px";
box1.style.height = "300px";
```

通过style属性，**只能设置和读取的都是行内样式**

### 2、读取元素当前的样式

（1）currentStyle

语法：元素.currentStyle.样式名

它可以用来读取**当前元素正在显示的样式**（生效的样式），如果当前元素没有设置该样式，则获取它的**默认值**，currentStyle**只有IE浏览器支持**，其他的浏览器都不支持

```
box1.currentStyle.backgroundColor
```

（2）getComputedStyle()

获取元素当前的样式，这个方法是**window的方法**，可以直接使用

需要两个参数

   * 		第一个：要获取样式的元素
   * 		第二个：可以传递一个伪元素，一般都传null
   * 		该方法会返回一个对象，对象中封装了当前元素对应的样式，可以通过对象.样式名来读取样式
   * 		如果获取的样式没有设置，则会获取到**真实的值**，而不是默认值，比如：没有设置width，它不会获取到auto，而是一个长度
   * 		但是该方法**不支持IE8及以下的浏览器**

```
getComputedStyle(box1,null).width
```

**注意：通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改，如果要修改必须通过style属性**，**它们的返回结果带有单位**

（3）为了兼容所有的浏览器

```
/*
			 * 定义一个函数，用来获取指定元素的当前的样式
			 * 参数：
			 * 		obj 要获取样式的元素
			 * 		name 要获取的样式名
			 */
			
			function getStyle(obj , name){
				
				if(window.getComputedStyle){
					//正常浏览器的方式，具有getComputedStyle()方法
					return getComputedStyle(obj , null)[name];
				}else{
					//IE8的方式，没有getComputedStyle()方法
					return obj.currentStyle[name];
				}
				
				//return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name];
				
			}
```

### 3、其他样式操作的属性

（1）clientWidth       clientHeight

这两个属性可以获取元素的可见宽度和高度，这些属性都是**不带px**的，返回都是一个数字，可以直接进行计算
会获取元素宽度和高度，包括**内容区和内边距，不包括边框**

**这些属性都是只读的，不能修改**

```
alert(box1.clientWidth);
alert(box1.clientHeight);
```

（2）offsetWidth        offsetHeight

获取元素的整个的宽度和高度，**包括内容区、内边距和边框，不可修改**

（3）offsetParent
可以用来获取**当前元素的定位父元素**，会获取到离当前元素最近的开启了定位的祖先元素，如果所有的祖先元素都没有开启定位，则返回body

```
var op = box1.offsetParent;
```

（4）offsetLeft
当前元素相对于其定位父元素的水平偏移量

（5）offsetTop
当前元素相对于其定位父元素的垂直偏移量

（6）scrollWidth      scrollHeight
可以获取元素整个滚动区域的宽度和高度

```
alert(box4.clientHeight);
alert(box4.scrollWidth);
```

（7）scrollLeft
可以获取水平滚动条滚动的距离
（8）scrollTop
可以获取垂直滚动条滚动的距离

## 应用

### 1、切换图片

实质是切换图片数组的索引，需要注意的是每次切换都需要判断是否为第一张或最后一张，如果是又怎么操作

### 2、判断水平、垂直滚动条是否到底

```
	//当满足scrollHeight - scrollTop == clientHeight//说明垂直滚动条滚动到底了	
	//当满足scrollWidth - scrollLeft == clientWidth//说明水平滚动条滚动到底
```

### 3、移动鼠标元素也移动-兼容性及其他问题

### 4、给一组元素节点绑定相同的处理函数

将处理函数抽出来，再给每个元素绑定（处理事件都指向同一对象的内存地址，避免浪费栈内存。否则每绑定一次事件，就要在栈内存开辟一次空间存储函数）

### 5、拖拽

拖拽的流程

​         \*    1.当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown

​         \*    2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove

​         \*    3.当鼠标松开时，被拖拽元素固定在当前位置  onmouseup

```
	//为document绑定一个鼠标松开事件，如果给元素绑定事件，由于元素设置了定位。当元素经过其他元素时，事件对象将会发生改变，从而不会触发元素的响应函数处理事件，所以必须给document绑定事件
					document.onmouseup = function(){
						//当鼠标松开时，被拖拽元素固定在当前位置	onmouseup
						//取消document的onmousemove事件
						document.onmousemove = null;
						//取消document的onmouseup事件
						document.onmouseup = null;
					};           
```

#### 1、鼠标与元素的相对位置不变

![image-20230221120855036](C:\Users\ydy\AppData\Roaming\Typora\typora-user-images\image-20230221120855036.png)

方法：移动元素（我们无法移动鼠标，因为鼠标由用户控制）

在第一阶段计算出相对位置=鼠标位置-元素偏移的位置

在第二阶段，移动元素的距离=鼠标位置-相对位置

#### 2、取消鼠标的默认事件

当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，这个个是浏览器提供的默认行为，如果不希望发生这个行为，则可以通过return false来取消默认行为，但是这招对IE8不起作用

方法：setCapture()当调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上

​            - 只有IE支持，但是在火狐中调用时不会报错而如果使用chrome调用，会报错

```
     *///设置box1捕获所有鼠标按下的事件

​          /*if(box1.setCapture){

​            box1.setCapture();

​          }*/

​          obj.setCapture && obj.setCapture();
```

```
//当鼠标松开时，取消对事件的捕获
						obj.releaseCapture && obj.releaseCapture();
```

### 6、滚轮事件



### 7、键盘事件

# BOM

浏览器对象模型

BOM可以使我们通过JS来操作浏览器

在BOM中为我们提供了一组对象，用来完成对浏览器的操作

BOM对象

 * Window

   代表的是整个浏览器的窗口，同时window也是网页中的全局对象

 * Navigator

   代表的当前浏览器的信息，通过该对象可以来**识别不同的浏览器**

   ```
   /*
   			 * Navigator
   			 * 	- 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
   			 * 	- 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了
   			 * 	- 一般我们只会使用userAgent来判断浏览器的信息，
   			 * 		userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，
   			 * 		不同的浏览器会有不同的userAgent
   			 * 
   			 * 火狐的userAgent
   			 * 	Mozilla/5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0
   			 * 
   			 * Chrome的userAgent
   			 *  Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36
   			 * 
   			 * IE8
   			 * 	Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)
   			 * 
   			 * IE9
   			 * 	Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)
   			 * 
   			 * IE10
   			 * 	Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)
   			 * 
   			 * IE11
   			 * 	Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko
   			 * 	- 在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了
   			 */
   			
   			//alert(navigator.appName);
   			
   			var ua = navigator.userAgent;
   			
   			console.log(ua);
   			
   			if(/firefox/i.test(ua)){
   				alert("你是火狐！！！");
   			}else if(/chrome/i.test(ua)){
   				alert("你是Chrome");
   			}else if(/msie/i.test(ua)){
   				alert("你是IE浏览器~~~");
   			}else if("ActiveXObject" in window){
   				alert("你是IE11，枪毙了你~~~");
   			}
   			
   			/*
   			 * 如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息
   			 * 比如：ActiveXObject
   			 */
   			/*if("ActiveXObject" in window){
   				alert("你是IE，我已经抓住你了~~~");
   			}else{
   				alert("你不是IE~~~");
   			}*/
   			
   			/*alert("ActiveXObject" in window);*/
   ```

 * Location

   代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者**操作浏览器跳转页面**

   ```
   	//如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）
   					//alert(location);
   					
   					/*
   					 * 如果直接将location属性修改为一个完整的路径，或相对路径
   					 * 	则我们页面会自动跳转到该路径，并且会生成相应的历史记录
   					 */
   					//location = "http://www.baidu.com";
   					//location = "01.BOM.html";
   					
   					/*
   					 * assign()
   					 * 	- 用来跳转到其他的页面，作用和直接修改location一样
   					 */
   					//location.assign("http://www.baidu.com");
   					
   					/*
   					 * reload()
   					 * 	- 用于重新加载当前页面，作用和刷新按钮一样
   					 * 	- 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面
   					 */
   					//location.reload(true);
   					
   					/*
   					 * replace()
   					 * 	- 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面
   					 * 		不会生成历史记录，不能使用回退按钮回退
   					 */
   ```

 * History

   代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录。可以用来**操作浏览器向前或向后翻页**

   由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效

   ```
   /*
   					 * length
   					 * 	- 属性，可以获取到当成访问的链接数量
   					 */
   					//alert(history.length);
   					
   					/*
   					 * back()
   					 * 	- 可以用来回退到上一个页面，作用和浏览器的回退按钮一样
   					 */
   					//history.back();
   					
   					/*
   					 * forward()
   					 * 	- 可以跳转下一个页面，作用和浏览器的前进按钮一样
   					 */
   					history.forward();
   					
   					/*
   					 * go()
   					 * 	- 可以用来跳转到指定的页面
   					 * 	- 它需要一个整数作为参数
   					 * 		1:表示向前跳转一个页面 相当于forward()
   					 * 		2:表示向前跳转两个页面
   					 * 		-1:表示向后跳转一个页面
   					 * 		-2:表示向后跳转两个页面
   					 */
   //					history.go(-2);
   				};
   ```

 * Screen

   代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息

这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用

# 定时器

setInterval()定时调用

   * 可以将一个函数，每隔一段时间执行一次

   * 参数：

     回调函数，该函数会每隔一段时间被调用一次

     每次调用间隔的时间，单位是毫秒

   * 返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识

```
	var num = 1;
				
				var timer = setInterval(function(){
					
					count.innerHTML = num++;
					
					if(num == 11){
						//关闭定时器
						clearInterval(timer);
					}
					
				},1000);
```

